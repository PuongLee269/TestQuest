<!doctype html>
<html lang="vi">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover">
<link rel="icon" type="image/png" href="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR42mNkYAAAAAYAAjCB0C8AAAAASUVORK5CYII=">
<meta name="theme-color" content="#8b7cff">
<title data-app="document-title">Mori Quest</title>
<style>
:root{
  --ink:#1b1e2e;
  --muted:#7d82a8;
  --tap:46px;
  --radius-card:16px;
  --radius-pill:999px;
  --gradient-main:linear-gradient(135deg,#8b7cff 0%,#b09bff 100%);
  --panel-bg:rgba(255,255,255,.85);
  --panel-border:rgba(0,0,0,.05);
  --panel-shadow:0 16px 40px rgba(0,0,0,.1);
}

*{box-sizing:border-box}
html,body{height:100%}
body{
  margin:0;
  color:var(--ink);
  font:16px/1.55 system-ui,-apple-system,Segoe UI,Roboto,sans-serif;
  background:#f6f7ff;
  background-attachment:fixed;
}

.wrap{max-width:960px;margin:12px auto;padding:20px;}

h1{margin:0 0 12px;display:flex;flex-direction:column;align-items:flex-start;gap:4px}
h1 .app-title{font-size:24px;font-weight:600;color:#1b1e2e;}
h1 .app-version{font-size:14px;font-weight:500;color:var(--muted);}

/* Hero */
.hero{
  position:relative;border-radius:24px;background:var(--gradient-main);
  background-size:cover;background-position:center;color:#fff;
  overflow:hidden;margin-bottom:20px;box-shadow:0 24px 48px rgba(139,124,255,.35);
}
.hero::before{
  content:"";position:absolute;inset:0;
  background:linear-gradient(135deg,rgba(10,14,39,.55),rgba(10,14,39,.25));
}
.hero-inner{
  position:relative;z-index:1;display:flex;flex-direction:column;
  align-items:flex-start;gap:20px;padding:28px;text-align:left;
}
.hero-info{flex:1;min-width:0}
.hero-name{margin:0;font-size:26px;font-weight:700;letter-spacing:.4px;}
.hero-meta{margin-top:8px;display:flex;flex-wrap:wrap;gap:12px;font-size:16px;font-weight:500;}
.hero-progress{margin-top:18px;width:100%}
.hero-progress-bar{height:10px;background:rgba(255,255,255,.35);border-radius:999px;overflow:hidden;}
.hero-progress-fill{
  height:100%;width:0;
  background:linear-gradient(90deg,#ff5f6d,#ffc371,#f9f871,#a8ff78,#78ffd6,#57c7ff,#9d50bb);
  background-size:300% 100%;border-radius:999px;transition:width .6s ease;
  animation:hero-progress-rainbow 6s linear infinite;
}
@keyframes hero-progress-rainbow{0%{background-position:0% 50%}50%{background-position:100% 50%}100%{background-position:0% 50%}}
.hero-progress-label{margin-top:8px;font-size:14px;opacity:.9;}

/* Tabs */
.tabs{display:flex;flex-wrap:wrap;gap:8px;margin-bottom:16px;overflow-x:auto;padding-bottom:4px;}
.tab-btn{
  display:flex;align-items:center;justify-content:center;min-height:var(--tap);
  padding:8px 14px;border:1px solid var(--panel-border);background:rgba(255,255,255,.8);
  border-radius:12px;cursor:pointer;white-space:nowrap;font-weight:500;
  box-shadow:0 6px 16px rgba(0,0,0,.08);color:#1b1e2e;font-size:18px;
}
.tab-btn.active{background:var(--gradient-main);color:#fff;border-color:transparent;box-shadow:0 10px 20px rgba(139,124,255,.4);}

/* Buttons */
.btn-primary{
  min-height:var(--tap);background:var(--gradient-main);color:#fff;border:none;
  border-radius:12px;padding:10px 14px;font-weight:500;cursor:pointer;
  box-shadow:0 10px 20px rgba(139,124,255,.4);font-size:14px;
}
.btn-ghost{
  min-height:var(--tap);background:rgba(255,255,255,.8);border:1px solid var(--panel-border);
  border-radius:12px;padding:10px 14px;font-size:14px;font-weight:500;color:#1b1e2e;
  box-shadow:0 6px 16px rgba(0,0,0,.08);cursor:pointer;
}
.btn-danger{
  min-height:var(--tap);background:linear-gradient(135deg,#ff5f48 0%,#ff3425 100%);
  color:#fff;border:none;border-radius:12px;padding:10px 14px;font-weight:500;
  cursor:pointer;box-shadow:0 10px 20px rgba(255,60,48,.4);font-size:14px;
}
.btn-primary.btn-sm,.btn-ghost.btn-sm,.btn-danger.btn-sm{min-height:36px;padding:6px 12px;font-size:13px;}

/* UI Elements */
.pill{background:rgba(255,255,255,.8);border:1px solid var(--panel-border);border-radius:var(--radius-pill);padding:4px 10px;font-size:14px;font-weight:500;color:#1b1e2e;}
.task-points{font-weight:bold;margin-left:8px;font-size:14px;display:inline-flex;align-items:center;gap:4px;}
.task-points.positive{color:#16a34a;}
.task-points.negative{color:#dc2626;}
.task-kind{
  display:inline-flex;align-items:center;padding:2px 8px;margin-left:8px;
  font-size:11px;font-weight:600;border-radius:999px;text-transform:uppercase;
  letter-spacing:.4px;background:rgba(139,124,255,.18);color:#5a4cc1;
}
.task-kind.single{background:rgba(34,197,94,.18);color:#1f9d55;}
.task-kind.recurring{background:rgba(59,130,246,.18);color:#2563eb;}
.task-kind.recurring.negative{background:rgba(248,113,113,.18);color:#dc2626;}
.top{display:flex;align-items:center;gap:8px;margin-bottom:12px;flex-wrap:wrap;}
input,select,textarea{
  height:var(--tap);padding:10px;border-radius:12px;border:1px solid rgba(0,0,0,.08);
  width:100%;font:inherit;font-size:14px;background:#fff;box-shadow:0 6px 16px rgba(0,0,0,.05);
}
input[type="checkbox"]{height:auto;width:auto;box-shadow:none;}

/* Layout & Cards */
.grid{display:grid;gap:10px;}
.row{display:grid;grid-template-columns:200px 1fr;gap:10px;align-items:flex-start;}
.card{
  padding:16px;border:1px solid var(--panel-border);border-radius:16px;
  background:var(--panel-bg);margin-top:16px;box-shadow:var(--panel-shadow);
  position:relative;overflow:hidden;
}
.card h3{margin:0 0 12px;font-size:16px;font-weight:600;color:#1b1e2e;}
.bar{height:10px;background:rgba(0,0,0,.07);border-radius:6px;overflow:hidden;margin-bottom:10px;}
.fill{height:100%;background:linear-gradient(90deg,#8b7cff 0%,#b09bff 100%);}

/* Tasks */
ul{list-style:none;margin:0;padding:0;}
.zone{
  border:1px solid rgba(0,0,0,.05);border-radius:16px;margin:16px 0;
  background:rgba(255,255,255,.8);box-shadow:0 12px 32px rgba(0,0,0,.08);overflow:hidden;
}
.zone header{
  display:flex;justify-content:space-between;align-items:center;padding:12px 16px;
  border-bottom:1px solid rgba(0,0,0,.05);background:linear-gradient(135deg,#fafbff 0%,#f6f7ff 100%);
  font-weight:500;color:#1b1e2e;
}
.zone header.imgHead{color:#fff;border-bottom:1px solid rgba(255,255,255,.3);background-size:cover;background-position:center;}
.badge{font-size:12px;padding:2px 8px;border-radius:var(--radius-pill);background:#fff;border:1px solid rgba(0,0,0,.07);font-weight:500;}

li.task{position:relative;border-top:1px solid rgba(0,0,0,.03);background:transparent;padding:0;overflow:hidden;}
.task-inner{display:flex;align-items:center;justify-content:space-between;padding:12px 16px;background:transparent;transition:transform .2s;}
.left{display:flex;align-items:flex-start;gap:10px;}
.done .txt{text-decoration:line-through;color:#9aa;}
.creator{display:flex;gap:8px;flex-wrap:wrap;margin:10px 0;}
.left input[type="checkbox"]{transform:scale(1.25);margin-top:4px;}

.task-info-group{display:flex;flex-direction:column;justify-content:center;flex:1;}
.task-top-line{display:flex;align-items:center;gap:8px;flex-wrap:wrap;line-height:1.4;}
.task-streak-line{font-size:12px;font-weight:600;margin-top:4px;display:flex;align-items:center;gap:4px;}
.streak-tag{color:#d97706;background:rgba(251,191,36,0.15);padding:1px 6px;border-radius:4px;}
.streak-tag.danger{color:#dc2626;background:rgba(248,113,113,0.15);}
.streak-tag.crown{color:#7c3aed;background:rgba(139,92,246,0.15);}

.del-btn{
  position:absolute;right:0;top:0;bottom:0;width:60px;min-width:60px;padding:0;border:none;
  background:linear-gradient(135deg,#ff5f48 0%,#ff3425 100%);color:#fff;font-size:20px;
  font-weight:600;display:flex;align-items:center;justify-content:center;
  box-shadow:-4px 0 16px rgba(0,0,0,.2);transition:transform .2s;transform:translateX(60px);
}
li.task.show-del .task-inner{transform:translateX(-60px);}
li.task.show-del .del-btn{transform:translateX(0);}
li.task.dragging .task-inner, li.task.dragging .del-btn{transition:none;}

/* Notes */
.notes-editor{width:100%;min-height:260px;padding:14px;border-radius:12px;border:1px solid var(--panel-border);background:rgba(255,255,255,.9);resize:vertical;font:inherit;}

@media (max-width:768px){
  .row{grid-template-columns:1fr;}
  .creator{flex-direction:column;}
}
</style>
</head>
<body>

<div class="wrap">
  <h1>
    <span class="app-title" data-app="title">Mori Quest</span>
    <span class="app-version" data-app="version"></span>
  </h1>

  <section id="hero" class="hero">
    <div class="hero-inner">
      <div class="hero-info">
        <div class="hero-name" data-hero="name">Player</div>
        <div class="hero-meta">
          <span class="hero-level" data-hero="level">Level 1</span>
          <span class="hero-xp" data-hero="xp">0 E</span>
        </div>
        <div class="hero-progress">
          <div class="hero-progress-bar">
            <div class="hero-progress-fill" data-hero="xp-fill"></div>
          </div>
          <div class="hero-progress-label" data-hero="xp-label">0 / 100 E</div>
        </div>
      </div>
    </div>
  </section>

  <div class="tabs" id="tabsBar"></div>
  <div id="view">ƒêang n·∫°p‚Ä¶</div>
</div>

<script>
/* ==============================
   CONFIG & CONSTANTS
============================== */
const APP_NAME = 'Mori Quest';
const CONFIG = {
  VERSION:'2.1', // Updated version
  SETTINGS_PASS:'1000'
};

const ZONE_KIND_LABELS = {
  'e':'Zone E',
  'priority':'Zone Quan tr·ªçng',
  'noise':'Zone Noise',
  'regular':'Zone Th∆∞·ªùng'
};
const ZONE_KIND_ORDER = ['e','priority','noise','regular'];
const DEFAULT_ZONES = ZONE_KIND_ORDER.map((kind)=>({
  name: ZONE_KIND_LABELS[kind], kind, bg:''
}));

/* ==============================
   LOCAL STORAGE KEYS
============================== */
const LS = {
  PROFILE:'tq_profile',
  ZONES:'tq_zones',
  TASKS:'tq_tasks',
  RECUR:'tq_recurring',
  DAY:'tq_sim_day',
  BONUS:'tq_bonus_flags',
  HIST:'tq_hist',
  THEME:'tq_theme',
  NOTES:'tq_notes',
  ZONE_E_PROGRESS:'tq_zone_e_progress' // Store complex E logic
};

/* ==============================
   CORE HELPERS
============================== */
function load(key, def){ try{ return JSON.parse(localStorage.getItem(key)) ?? def }catch{ return def } }
function save(key, val){ localStorage.setItem(key, JSON.stringify(val)) }

function getProfile(){
  let p = load(LS.PROFILE);
  if(!p || typeof p!=='object' || Array.isArray(p)){
    p = { id:Date.now().toString(), name:'', level:1, xp:0 };
    save(LS.PROFILE, p);
  }
  return p;
}

const LEVELS = [
  {lvl:1, need:100}, {lvl:2, need:250}, {lvl:3, need:500},
  {lvl:4, need:800}, {lvl:5, need:1200}, {lvl:6, need:1700},
  {lvl:7, need:2300}, {lvl:8, need:3000}, {lvl:9, need:3800}
];
function lastLevelCfg(){ return LEVELS[LEVELS.length-1]; }

function getLevelInfo(){
  const p=getProfile();
  const cfg = LEVELS.find(x=>x.lvl===p.level) || lastLevelCfg();
  return {level:p.level, xp:p.xp, need:cfg.need||0};
}

function addXP(delta){
  const p=getProfile();
  p.xp = Math.max(0, Number(p.xp||0)+Number(delta||0));
  while(true){
    const cfg = LEVELS.find(x=>x.lvl===p.level) || lastLevelCfg();
    const need = cfg.need || 0;
    if(need>0 && p.xp>=need){
      p.xp -= need;
      const maxLvl = lastLevelCfg().lvl;
      p.level = Math.min(maxLvl, p.level+1);
    } else {
      break;
    }
  }
  save(LS.PROFILE,p);
  renderHero();
}

function setName(name){
  const p=getProfile(); p.name=(name||'').trim(); save(LS.PROFILE,p);
  renderHero();
}

function getZoneEProgress(){
  return load(LS.ZONE_E_PROGRESS, {});
}

function setZoneEProgress(data){
  save(LS.ZONE_E_PROGRESS, data);
}

/* ==============================
   LOGIC: POINTS & SCORING (FIXED)
============================== */
// Y√™u c·∫ßu: E=1, Noise=-1, Priority=3, Regular=1
function getTaskPoints(zoneKind, customPoints) {
  // N·∫øu task ƒë√£ c√≥ ƒëi·ªÉm custom (t·ª´ Zone E level up/noise penalty), d√πng n√≥
  if (typeof customPoints === 'number') return customPoints;

  switch (zoneKind) {
    case 'e': return 1;
    case 'priority': return 3;
    case 'noise': return -1;
    case 'regular': return 1;
    default: return 1;
  }
}

/* ==============================
   RENDER HERO
============================== */
const heroEl = document.getElementById('hero');
const heroRefs = heroEl ? {
  name: heroEl.querySelector('[data-hero="name"]'),
  level: heroEl.querySelector('[data-hero="level"]'),
  xp: heroEl.querySelector('[data-hero="xp"]'),
  xpFill: heroEl.querySelector('[data-hero="xp-fill"]'),
  xpLabel: heroEl.querySelector('[data-hero="xp-label"]')
} : {};

(function syncAppMeta(){
  document.title = APP_NAME;
  const nameEl = document.querySelector('[data-app="title"]');
  if(nameEl) nameEl.textContent = APP_NAME;
  const versionEl = document.querySelector('[data-app="version"]');
  if(versionEl) versionEl.textContent = `v${CONFIG.VERSION}`;
})();

function renderHero(){
  if(!heroEl) return;
  const p = getProfile();
  const {level,xp,need} = getLevelInfo();
  const pct = need ? Math.min(100, Math.round(xp/need*100)) : 100;

  // Background logic (Simplified)
  let bg = 'linear-gradient(135deg,#8b7cff 0%,#b09bff 100%)';
  if(level>=4 && level<=6) bg = 'linear-gradient(135deg,#bae6fd 0%,#2563eb 100%)';
  if(level>=7) bg = 'linear-gradient(135deg,#e9d5ff 0%,#7c3aed 100%)';
  
  // Apply saved custom theme if any
  const theme = load(LS.THEME, {});
  if(theme.heroBgUrl) heroEl.style.backgroundImage = `url('${theme.heroBgUrl}')`;
  else heroEl.style.backgroundImage = bg;

  if(theme.appBgUrl) document.body.style.backgroundImage = `url('${theme.appBgUrl}')`;
  else document.body.style.backgroundImage = '';

  if(heroRefs.name) heroRefs.name.textContent = p.name || 'Player';
  if(heroRefs.level) heroRefs.level.textContent = `Level ${level}`;
  if(heroRefs.xp) heroRefs.xp.textContent = `${xp} E`;
  if(heroRefs.xpLabel) heroRefs.xpLabel.textContent = need ? `${xp} / ${need} E` : 'Max';
  if(heroRefs.xpFill) heroRefs.xpFill.style.width = `${pct}%`;
}

/* ==============================
   DATA MANAGEMENT
============================== */
function getZones(){
  let zones = load(LS.ZONES, []);
  if(!zones.length) zones = DEFAULT_ZONES.map((z,i)=>({id:Date.now()+i, ...z}));
  return zones;
}
function setZones(z){ save(LS.ZONES,z) }
function getTasks(){ return load(LS.TASKS, []) }
function setTasks(t){ save(LS.TASKS, t) }
function getRecurring(){ return load(LS.RECUR, []) }
function saveRecurring(r){ save(LS.RECUR, r) }

function isTaskActiveToday(t){ return t.kind==='recurring' || !t.done; }
function doesTaskOccupyCapacity(t){ return true; } // Simplification

/* ==============================
   DAY LOGIC & ROLLOVER
============================== */
function getDay(){ return Number(localStorage.getItem(LS.DAY)||1); }
function nextDay(){ localStorage.setItem(LS.DAY, getDay()+1); }

function performDayRollover(){
  const zones = getZones();
  const tasks = getTasks();
  const recs = getRecurring();
  const zoneEMap = getZoneEProgress();
  const nextZoneEMap = { ...zoneEMap };
  const zoneKindMap = new Map(zones.map(z => [z.id, z.kind]));

  // 1. Apply Penalty (-7 for day rollover)
  addXP(-7);

  // 2. Zone E Bonus Logic (Daily Completion Bonus)
  const todayTasks = tasks.filter(t => t.done);
  const completedZoneECount = todayTasks.reduce((c, t) => zoneKindMap.get(t.zoneId) === 'e' ? c + 1 : c, 0);
  if (completedZoneECount > 3) {
    // Bonus 3-5 points
    const bonus = Math.min(5, Math.max(3, completedZoneECount));
    addXP(bonus);
  }

  // 3. Complex Progression Logic for Zone E Recurring Tasks
  // Iterate through all recurring definitions
  recs.forEach(rec => {
    const zKind = zoneKindMap.get(rec.zoneId);
    if (zKind !== 'e') return;

    const recKey = `rec:${rec.id}`;
    let data = nextZoneEMap[recKey] || { 
      points: 1, 
      streak: 0, 
      progress: 0, // Task count towards next level
      threshold: 5 
    };

    // Check if task was done today
    // Find the spawned task for this recurring ID
    const spawnedTask = tasks.find(t => t.kind === 'recurring' && t.recurringId === rec.id);
    const isDone = spawnedTask && spawnedTask.done;

    if (isDone) {
      data.streak++;
      
      // Logic: Only gain permanent level progress if points < 7
      if (data.points < 7) {
        data.progress++;
        if (data.progress >= data.threshold) {
          // LEVEL UP!
          data.points++;
          data.progress = 0;
          // Formula: Previous * 1.2 rounded up
          data.threshold = Math.ceil(data.threshold * 1.2);
        }
      }
      
    } else {
      // Missed the day
      if (data.points >= 7) {
        // Crown penalty: Drop 1 level
        data.points--;
        // Reset threshold logic? Let's keep it simple, just drop point.
        // Re-calculate threshold for the new lower level? 
        // Reverse engineering 7->6: 
        // 1->2 (5), 2->3 (6), 3->4 (8), 4->5 (10), 5->6 (12), 6->7 (15)
        // Just resetting progress is safer.
        data.progress = 0; 
        // Approximate threshold restore (not perfect but functional)
        data.threshold = Math.floor(data.threshold / 1.2) || 5; 
      } else {
        // Pre-crown penalty: Reset to 1
        data.points = 1;
        data.streak = 0;
        data.progress = 0;
        data.threshold = 5;
      }
    }

    nextZoneEMap[recKey] = data;
  });
  setZoneEProgress(nextZoneEMap);

  // 4. Zone Noise Logic (Accumulating Penalty)
  // Noise accumulates -1 for every day done. 
  // However, the requirement says "Zone Noise only removable at -1". 
  // We need to increase penalty if they keep doing it.
  recs.forEach(rec => {
    if (zoneKindMap.get(rec.zoneId) !== 'noise') return;
    
    const spawnedTask = tasks.find(t => t.kind === 'recurring' && t.recurringId === rec.id);
    if (spawnedTask && spawnedTask.done) {
       // Increase penalty (more negative)
       // Current logic: rec.points starts at -1.
       // If done today, points = points - 1;
       // But we need to store this statefully. 
       // Let's use the task's points directly for next spawn.
       rec.points = (rec.points || -1) - 1; 
    }
  });
  saveRecurring(recs);

  // 5. Spawn New Tasks
  nextDay();
  const nextTasks = tasks.filter(t => t.kind === 'single' && !t.done); // Keep unfinished singles
  
  // Spawn recurring
  const dayIndex = new Date().getDay(); // 0=Sun
  recs.forEach(r => {
    if(r.type==='weekly' && (!r.days || !r.days.includes(dayIndex))) return;
    
    // Calculate points for the new spawn
    let p = 0;
    const zKind = zoneKindMap.get(r.zoneId);
    
    if (zKind === 'e') {
       const data = nextZoneEMap[`rec:${r.id}`];
       p = data ? data.points : 1;
    } else if (zKind === 'noise') {
       p = r.points || -1; // Use stored penalty
    } else {
       p = getTaskPoints(zKind);
    }

    nextTasks.push({
      id: Date.now() + Math.random(),
      text: r.text,
      zoneId: r.zoneId,
      done: false,
      kind: 'recurring',
      recurringId: r.id,
      points: p
    });
  });

  setTasks(nextTasks);
  render('settings'); // Re-render settings to update view
  alert('ƒê√£ qua ng√†y m·ªõi! (-7 E ph√≠ sinh ho·∫°t)');
}

/* ==============================
   UI RENDERING
============================== */
const view = document.getElementById('view');
const tabsBar = document.getElementById('tabsBar');
let currentTab = 'tasks';

function buildTabsBar(active){
  tabsBar.innerHTML = [
    {id:'tasks', label:'Nhi·ªám v·ª•', icon:'‚úÖ'},
    {id:'settings', label:'C√†i ƒë·∫∑t', icon:'‚öôÔ∏è'}
  ].map(t=>`
    <button class="tab-btn ${t.id===active?'active':''}" onclick="render('${t.id}')">
      ${t.icon} ${t.label}
    </button>
  `).join('');
}

/* --- VIEW: TASKS --- */
function viewTasks(){
  const zones = getZones();
  const tasks = getTasks();
  const zoneEMap = getZoneEProgress();
  const dateNow = new Date().toLocaleDateString('vi-VN');
  
  // Group tasks by zone
  const groups = zones.map(z => {
    return {
      z,
      list: tasks.filter(t => t.zoneId == z.id)
    };
  });

  view.innerHTML = `
    <div class="top">
      <span class="pill">Ng√†y m√¥ ph·ªèng: <b>${getDay()}</b></span>
      <span class="pill">Th·ª±c t·∫ø: <b>${dateNow}</b></span>
    </div>

    <div class="creator">
      <input id="taskText" placeholder="Nh·∫≠p nhi·ªám v·ª• m·ªõi...">
      <select id="taskZone">${zones.map(z=>`<option value="${z.id}">${z.name}</option>`).join('')}</select>
      <button class="btn-primary" id="btnAdd">Th√™m</button>
    </div>

    ${groups.map(g => {
      if(!g.list.length) return ''; // Hide empty zones to clean up UI? Or keep them. Let's keep.
      
      const listHtml = g.list.map(t => {
        // Zone E Info
        let subHtml = '';
        if (g.z.kind === 'e' && t.kind === 'recurring') {
           const data = zoneEMap[`rec:${t.recurringId}`];
           if (data) {
             const isCrown = data.points >= 7;
             subHtml = `
               <div class="task-streak-line">
                 ${isCrown ? '<span class="streak-tag crown">üëë Vua l√¨ ƒë√≤n</span>' : ''}
                 <span class="streak-tag">Streak: ${data.streak} ng√†y</span>
                 ${!isCrown ? `<span class="muted" style="font-size:11px;margin-left:4px">(${data.progress}/${data.threshold} ƒë·ªÉ +1 E)</span>` : ''}
               </div>
             `;
           }
        }
        // Zone Noise Info
        if (g.z.kind === 'noise' && t.points < -1) {
             subHtml = `
               <div class="task-streak-line">
                 <span class="streak-tag danger">üíÄ Ph·∫°t n·∫∑ng: ${t.points} E</span>
               </div>
             `;
        }

        return `
          <li class="task ${t.done?'done':''}" data-id="${t.id}">
            <div class="task-inner">
              <div class="left">
                <input type="checkbox" ${t.done?'checked':''} onchange="toggleTask(${t.id}, this.checked)">
                <div class="task-info-group">
                  <div class="task-top-line">
                    <span class="txt">${t.text}</span>
                    ${renderTaskKindBadge(t, g.z)}
                    <span class="task-points ${t.points>=0?'positive':'negative'}">
                      ${t.points>0?'+':''}${t.points}
                    </span>
                  </div>
                  ${subHtml}
                </div>
              </div>
            </div>
            <button class="del-btn" onclick="deleteTask(${t.id}, '${g.z.kind}', ${t.points})">√ó</button>
          </li>
        `;
      }).join('');

      return `
        <section class="zone">
          <header>
            <div><b>${g.z.name}</b></div>
          </header>
          <ul>${listHtml || '<li class="task"><div class="task-inner muted">Tr·ªëng</div></li>'}</ul>
        </section>
      `;
    }).join('')}
  `;

  // Swipe logic setup
  attachSwipeHandlers();

  // Bind Add
  document.getElementById('btnAdd').onclick = addTask;
  document.getElementById('taskText').onkeydown = (e) => e.key==='Enter' && addTask();
}

function renderTaskKindBadge(t, z){
  if(t.kind==='recurring') return `<span class="task-kind recurring">L·∫∑p l·∫°i</span>`;
  return `<span class="task-kind single">M·ªôt l·∫ßn</span>`;
}

function addTask(){
  const txt = document.getElementById('taskText').value.trim();
  const zid = Number(document.getElementById('taskZone').value);
  if(!txt) return;

  const zones = getZones();
  const z = zones.find(x=>x.id===zid);
  
  // Points logic
  let pts = getTaskPoints(z.kind);
  
  const newTask = {
    id: Date.now(),
    text: txt,
    zoneId: zid,
    done: false,
    kind: 'single',
    points: pts
  };

  // If adding to daily zone (E or Noise), prompt for recurring? 
  // Simplification: Default single. User can add recurring in Settings.
  // Or auto-convert for this demo:
  if (z.kind === 'e' || z.kind === 'noise') {
     // For this specific request logic to work (Zone E leveling), it implies recurring.
     // Let's auto-create a recurring definition for E/Noise added from main screen
     const recId = Date.now();
     const recs = getRecurring();
     recs.push({
       id: recId,
       text: txt,
       zoneId: zid,
       type: 'daily',
       points: pts
     });
     saveRecurring(recs);
     newTask.kind = 'recurring';
     newTask.recurringId = recId;
  }

  const tasks = getTasks();
  tasks.push(newTask);
  setTasks(tasks);
  document.getElementById('taskText').value = '';
  viewTasks();
}

function toggleTask(id, checked){
  const tasks = getTasks();
  const t = tasks.find(x=>x.id===id);
  if(!t) return;
  
  t.done = checked;
  addXP(checked ? t.points : -t.points);
  setTasks(tasks);
  viewTasks();
}

// LOGIC X√ìA NOISE QUAN TR·ªåNG ·ªû ƒê√ÇY
function deleteTask(id, zoneKind, currentPoints){
  if (zoneKind === 'noise' && currentPoints < -1) {
    // Logic: Kh√¥ng cho x√≥a, bu·ªôc reset v·ªÅ -1
    if(confirm(`Task n√†y ƒëang b·ªã ph·∫°t n·∫∑ng (${currentPoints} ƒëi·ªÉm). B·∫°n c√≥ mu·ªën reset v·ªÅ -1 ƒëi·ªÉm ƒë·ªÉ x√≥a sau kh√¥ng?`)){
      const tasks = getTasks();
      const t = tasks.find(x=>x.id===id);
      if(t) {
        t.points = -1;
        // Update recurring definition too
        if(t.recurringId){
          const recs = getRecurring();
          const r = recs.find(x=>x.id===t.recurringId);
          if(r) r.points = -1;
          saveRecurring(recs);
        }
        setTasks(tasks);
        viewTasks();
      }
    }
    return;
  }

  // Normal delete
  const tasks = getTasks();
  const t = tasks.find(x=>x.id===id);
  if(t && t.recurringId){
     // Also remove recurring def? Yes for simple UX
     const recs = getRecurring().filter(r=>r.id!==t.recurringId);
     saveRecurring(recs);
  }
  setTasks(tasks.filter(x=>x.id!==id));
  viewTasks();
}

/* --- VIEW: SETTINGS --- */
function viewSettings(){
  const p = getProfile();
  view.innerHTML = `
    <div class="card" style="margin-top:0">
      <h3>ƒêi·ªÅu khi·ªÉn Ng√†y</h3>
      <div class="muted" style="margin-bottom:10px">N√∫t ƒëi·ªÅu khi·ªÉn ƒë√£ ƒë∆∞·ª£c hi·ªán l·∫°i.</div>
      <div class="grid" style="grid-template-columns:1fr 1fr;gap:10px">
        <button class="btn-primary" onclick="performDayRollover()">Qua ng√†y m·ªõi</button>
        <button class="btn-danger" onclick="if(confirm('Reset Level v·ªÅ 1?')) { resetPoints(); }">Reset ƒëi·ªÉm</button>
      </div>
    </div>

    <div class="card">
      <h3>H·ªì s∆°</h3>
      <div class="row">
        <div>T√™n</div>
        <input id="nameInput" value="${p.name}" onchange="setName(this.value)">
      </div>
    </div>

    <div class="card">
       <h3>Th√™m Task L·∫∑p (T√πy ch·ªânh)</h3>
       <div class="creator" style="flex-direction:column;align-items:stretch">
         <input id="rText" placeholder="T√™n task l·∫∑p...">
         <select id="rZone">${getZones().map(z=>`<option value="${z.id}">${z.name}</option>`).join('')}</select>
         <button class="btn-ghost" onclick="addRecManual()">Th√™m</button>
       </div>
    </div>
  `;
}

function resetPoints(){
  const p = getProfile();
  p.level = 1; p.xp = 0;
  save(LS.PROFILE, p);
  renderHero();
}

function addRecManual(){
  const txt = document.getElementById('rText').value;
  const zid = Number(document.getElementById('rZone').value);
  if(!txt) return;
  const zones = getZones();
  const z = zones.find(x=>x.id===zid);
  const recs = getRecurring();
  recs.push({
    id: Date.now(),
    text: txt,
    zoneId: zid,
    type: 'daily',
    points: getTaskPoints(z.kind)
  });
  saveRecurring(recs);
  alert('ƒê√£ th√™m task l·∫∑p');
}

/* ==============================
   SWIPE HANDLER (Touch)
============================== */
function attachSwipeHandlers(){
  document.querySelectorAll('li.task').forEach(li => {
    const delBtn = li.querySelector('.del-btn');
    let startX, currentX;
    let isDown = false;
    
    li.addEventListener('touchstart', e => {
      startX = e.touches[0].clientX;
      isDown = true;
    });
    
    li.addEventListener('touchmove', e => {
      if(!isDown) return;
      currentX = e.touches[0].clientX;
      const diff = currentX - startX;
      if (diff < -30) li.classList.add('show-del');
      if (diff > 30) li.classList.remove('show-del');
    });
    
    li.addEventListener('touchend', () => isDown = false);
    
    // Click outside to close
    li.querySelector('.task-inner').onclick = () => {
      if(li.classList.contains('show-del')) li.classList.remove('show-del');
    };
  });
}

/* ==============================
   ROUTER & INIT
============================== */
function render(tab){
  currentTab = tab;
  buildTabsBar(tab);
  renderHero();
  if(tab === 'tasks') viewTasks();
  else if(tab === 'settings') viewSettings();
}

// Init
render('tasks');
</script>
</body>
</html>
