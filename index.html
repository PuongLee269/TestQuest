<!doctype html>
<html lang="vi">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover">
<link rel="icon" type="image/png" href="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR42mNkYAAAAAYAAjCB0C8AAAAASUVORK5CYII=">
<meta name="theme-color" content="#8b7cff">
<title data-app="document-title">Mori Quest</title>
<style>
:root{
  --ink:#1b1e2e;
  --muted:#7d82a8;
  --tap:46px;
  --radius-card:16px;
  --radius-pill:999px;
  --gradient-main:linear-gradient(135deg,#8b7cff 0%,#b09bff 100%);
  --panel-bg:rgba(255,255,255,.85);
  --panel-border:rgba(0,0,0,.05);
  --panel-shadow:0 16px 40px rgba(0,0,0,.1);
  --glass-bg:rgba(255,255,255,.08);
}

*{box-sizing:border-box}
html,body{height:100%}
body{
  margin:0;
  color:var(--ink);
  font:16px/1.55 system-ui,-apple-system,Segoe UI,Roboto,sans-serif;
  background:#f6f7ff;
  background-attachment:fixed;
}

.wrap{
  max-width:960px;
  margin:12px auto;
  padding:20px;
}

h1{
  margin:0 0 12px;
  display:flex;
  flex-direction:column;
  align-items:flex-start;
  gap:4px
}

h1 .app-title{
  font-size:24px;
  font-weight:600;
  color:#1b1e2e;
}

h1 .app-version{
  font-size:14px;
  font-weight:500;
  color:var(--muted);
}

/* Hero */
.hero{
  position:relative;
  border-radius:24px;
  background:var(--gradient-main);
  background-size:cover;
  background-position:center;
  color:#fff;
  overflow:hidden;
  margin-bottom:20px;
  box-shadow:0 24px 48px rgba(139,124,255,.35);
}
.hero::before{
  content:"";
  position:absolute;
  inset:0;
  background:linear-gradient(135deg,rgba(10,14,39,.55),rgba(10,14,39,.25));
}
.hero-inner{
  position:relative;
  z-index:1;
  display:flex;
  flex-direction:column;
  align-items:flex-start;
  gap:20px;
  padding:28px;
  text-align:left;
}
.hero-info{flex:1;min-width:0}
.hero-name{
  margin:0;
  font-size:26px;
  font-weight:700;
  letter-spacing:.4px;
}
.hero-meta{
  margin-top:8px;
  display:flex;
  flex-wrap:wrap;
  gap:12px;
  font-size:16px;
  font-weight:500;
}
.hero-meta span{display:inline-flex;align-items:center;gap:6px}
.hero-progress{margin-top:18px;width:100%}
.hero-progress-bar{
  height:10px;
  background:rgba(255,255,255,.35);
  border-radius:999px;
  overflow:hidden;
}
.hero-progress-fill{
  height:100%;
  width:0;
  background:linear-gradient(90deg,#ff5f6d,#ffc371,#f9f871,#a8ff78,#78ffd6,#57c7ff,#9d50bb);
  background-size:300% 100%;
  box-shadow:0 6px 18px rgba(255,255,255,.35);
  border-radius:999px;
  transition:width .6s ease;
  animation:hero-progress-rainbow 6s linear infinite;
}
@keyframes hero-progress-rainbow{
  0%{background-position:0% 50%}
  50%{background-position:100% 50%}
  100%{background-position:0% 50%}
}
.hero-progress-label{
  margin-top:8px;
  font-size:14px;
  letter-spacing:.2px;
  opacity:.9;
}

/* Tabs bar */
.tabs{
  display:flex;
  flex-wrap:wrap;
  gap:8px;
  margin-bottom:16px;
  overflow-x:auto;
  padding-bottom:4px;
}
.tabs::-webkit-scrollbar{height:6px}
.tabs::-webkit-scrollbar-thumb{background:#ddd;border-radius:6px}

.tab-btn{
  display:flex;
  align-items:center;
  justify-content:center;
  min-height:var(--tap);
  padding:8px 14px;
  border:1px solid var(--panel-border);
  background:rgba(255,255,255,.8);
  border-radius:12px;
  cursor:pointer;
  white-space:nowrap;
  font-weight:500;
  box-shadow:0 6px 16px rgba(0,0,0,.08);
  color:#1b1e2e;
  font-size:18px;
}
.tab-btn.active{
  background:var(--gradient-main);
  color:#fff;
  border-color:transparent;
  box-shadow:0 10px 20px rgba(139,124,255,.4);
}

/* generic buttons */
.btn-primary{
  min-height:var(--tap);
  background:var(--gradient-main);
  color:#fff;border:none;border-radius:12px;
  padding:10px 14px;font-weight:500;
  cursor:pointer;
  box-shadow:0 10px 20px rgba(139,124,255,.4);
  font-size:14px;
}
.btn-ghost{
  min-height:var(--tap);
  background:rgba(255,255,255,.8);
  border:1px solid var(--panel-border);
  border-radius:12px;
  padding:10px 14px;
  font-size:14px;
  font-weight:500;
  color:#1b1e2e;
  box-shadow:0 6px 16px rgba(0,0,0,.08);
  cursor:pointer;
}
.btn-ghost:active{
  transform:translateY(1px);
  box-shadow:0 4px 12px rgba(0,0,0,.12);
}
.btn-ghost[disabled],
.btn-ghost[data-loading]{
  cursor:progress;
  opacity:.6;
  box-shadow:none;
  transform:none;
}
.btn-danger{
  min-height:var(--tap);
  background:linear-gradient(135deg,#ff5f48 0%,#ff3425 100%);
  color:#fff;border:none;border-radius:12px;
  padding:10px 14px;font-weight:500;
  cursor:pointer;
  box-shadow:0 10px 20px rgba(255,60,48,.4);
  font-size:14px;
}
.btn-primary.btn-sm,
.btn-ghost.btn-sm,
.btn-danger.btn-sm{
  min-height:36px;
  padding:6px 12px;
  font-size:13px;
}

/* pills */
.pill{
  background:rgba(255,255,255,.8);
  border:1px solid var(--panel-border);
  border-radius:var(--radius-pill);
  padding:4px 10px;
  font-size:14px;
  font-weight:500;
  color:#1b1e2e;
  box-shadow:0 6px 16px rgba(0,0,0,.08);
}
.task-points {
  font-weight: bold;
  margin-left: 8px;
  font-size: 14px;
  display: inline-flex;
  align-items: center;
  gap: 4px;
}
.task-points.positive { color: #16a34a; }
.task-points.negative { color: #dc2626; }
.task-points.neutral { color: #4b5563; }
.task-point-icon {
  display: inline-flex;
  align-items: center;
  font-size: 14px;
}
.task-kind{
  display:inline-flex;
  align-items:center;
  padding:2px 8px;
  margin-left:8px;
  font-size:11px;
  font-weight:600;
  border-radius:999px;
  text-transform:uppercase;
  letter-spacing:.4px;
  background:rgba(139,124,255,.18);
  color:#5a4cc1;
}
.task-kind.single{
  background:rgba(34,197,94,.18);
  color:#1f9d55;
}
.task-kind.recurring{
  background:rgba(59,130,246,.18);
  color:#2563eb;
}
.task-kind.recurring.negative{
  background:rgba(248,113,113,.18);
  color:#dc2626;
}
.task.done .task-kind{opacity:.7}
.muted{color:var(--muted);font-size:14px}
.top{
  display:flex;
  align-items:center;
  gap:8px;
  margin-bottom:12px;
  flex-wrap:wrap
}

/* Inputs */
input,select,textarea{
  height:var(--tap);
  padding:10px;
  border-radius:12px;
  border:1px solid rgba(0,0,0,.08);
  width:100%;
  font:inherit;
  font-size:14px;
  background:#fff;
  box-shadow:0 6px 16px rgba(0,0,0,.05);
}
input[type="checkbox"]{
  height:auto;width:auto;box-shadow:none;
}

/* layout (Settings rows) */
.grid{display:grid;gap:10px}
.row{
  display:grid;
  grid-template-columns:200px 1fr;
  gap:10px;
  align-items:flex-start;
}

.card{
  padding:16px;
  border:1px solid var(--panel-border);
  border-radius:16px;
  background:var(--panel-bg);
  margin-top:16px;
  box-shadow:var(--panel-shadow);
  position:relative;
  overflow:hidden;
}
.card h3{
  margin:0 0 12px;
  font-size:16px;
  font-weight:600;
  color:#1b1e2e;
}

.notes-header{
  display:flex;
  align-items:center;
  justify-content:space-between;
  gap:12px;
}

.notes-status{
  font-size:13px;
  color:var(--muted);
}

.notes-subtitle{
  margin:0 0 12px;
  font-size:14px;
  color:var(--muted);
}

.notes-editor{
  width:100%;
  min-height:260px;
  padding:14px;
  border-radius:12px;
  border:1px solid var(--panel-border);
  background:rgba(255,255,255,.9);
  box-shadow:inset 0 4px 12px rgba(0,0,0,.06);
  resize:vertical;
  font:16px/1.55 system-ui,-apple-system,Segoe UI,Roboto,sans-serif;
  color:var(--ink);
}

.notes-editor:focus{
  outline:none;
  border-color:rgba(139,124,255,.7);
  box-shadow:0 0 0 3px rgba(139,124,255,.18);
}

.bar{
  height:10px;
  background:rgba(0,0,0,.07);
  border-radius:6px;
  overflow:hidden;
  margin-bottom:10px;
  box-shadow:inset 0 2px 4px rgba(0,0,0,.12);
}
.fill{
  height:100%;
  background:linear-gradient(90deg,#8b7cff 0%,#b09bff 100%);
}

/* task lists */
ul{list-style:none;margin:0;padding:0}
.archive-toolbar{
  display:flex;
  justify-content:flex-end;
  gap:8px;
  flex-wrap:wrap;
  margin-top:12px;
}
.archive-list{
  display:flex;
  flex-direction:column;
  gap:12px;
  margin:16px 0 0;
}
.archive-item{
  display:flex;
  gap:12px;
  padding:12px;
  border:1px solid var(--panel-border);
  border-radius:12px;
  background:rgba(255,255,255,.8);
  box-shadow:0 6px 16px rgba(0,0,0,.06);
}
.archive-info{flex:1;min-width:0;}
.archive-title{font-weight:600;word-break:break-word;}
.archive-meta{
  display:flex;
  flex-wrap:wrap;
  gap:6px;
  margin-top:6px;
  font-size:12px;
  color:var(--muted);
  align-items:center;
}
.archive-meta .sep{color:rgba(0,0,0,.25);}
.archive-reason{
  margin-top:8px;
  font-size:13px;
  color:var(--muted);
  word-break:break-word;
}
.archive-actions{display:flex;align-items:center;gap:8px;}
.archive-empty{
  margin-top:12px;
  color:var(--muted);
}

.zone{
  border:1px solid rgba(0,0,0,.05);
  border-radius:16px;
  margin:16px 0;
  background:rgba(255,255,255,.8);
  box-shadow:0 12px 32px rgba(0,0,0,.08);
  overflow:hidden;
}
.zone header{
  display:flex;
  justify-content:space-between;
  align-items:center;
  padding:12px 16px;
  border-bottom:1px solid rgba(0,0,0,.05);
  background:linear-gradient(135deg,#fafbff 0%,#f6f7ff 100%);
  font-weight:500;
  color:#1b1e2e;
}
.zone header.imgHead{
  color:#fff;
  border-bottom:1px solid rgba(255,255,255,.3);
  background-size:cover;
  background-position:center;
  background-repeat:no-repeat;
  background-blend-mode:normal;
}
.zone header.imgHead .badge{
  background:rgba(0,0,0,.4);
  color:#fff;
  border:1px solid rgba(255,255,255,.3);
}

.badge{
  font-size:12px;
  padding:2px 8px;
  border-radius:var(--radius-pill);
  background:#fff;
  border:1px solid rgba(0,0,0,.07);
  color:#1b1e2e;
  font-weight:500;
  box-shadow:0 4px 10px rgba(0,0,0,.08);
}

/* swipe task row */
li.task{
  position:relative;
  border-top:1px solid rgba(0,0,0,.03);
  background:transparent;
  padding:0;
  overflow:hidden;
}
.task-inner{
  display:flex;
  align-items:center;
  justify-content:space-between;
  padding:12px 16px;
  background:transparent;
  transition:transform .2s;
}
.left{display:flex;align-items:flex-start;gap:10px}
.done .txt{text-decoration:line-through;color:#9aa}
.creator{display:flex;gap:8px;flex-wrap:wrap;margin:10px 0}
.left input[type="checkbox"]{transform:scale(1.25);margin-top:4px;}

.del-btn{
  position:absolute;
  right:0;
  top:0;
  bottom:0;
  width:60px;
  min-width:60px;
  padding:0;
  border:none;
  border-radius:0;
  background:linear-gradient(135deg,#ff5f48 0%,#ff3425 100%);
  color:#fff;
  font-size:20px;
  font-weight:600;
  line-height:1;
  display:flex;
  align-items:center;
  justify-content:center;
  box-shadow:-4px 0 16px rgba(0,0,0,.2);
  transition:transform .2s;
  transform:translateX(60px); /* ·∫©n ban ƒë·∫ßu */
}

li.task.show-del .task-inner{
  transform:translateX(-60px);
}
li.task.show-del .del-btn{
  transform:translateX(0);
}

/* t·∫Øt transition khi ƒëang k√©o */
li.task.dragging .task-inner{
  transition:none;
}
li.task.dragging .del-btn{
  transition:none;
}

/* Leaderboard table */
.table-wrap{
  overflow:auto;
  border:1px solid rgba(0,0,0,.05);
  border-radius:16px;
  background:rgba(255,255,255,.8);
  box-shadow:0 16px 32px rgba(0,0,0,.08);
}
table{
  width:100%;
  border-collapse:collapse;
  background:transparent;
  font-size:14px;
}
th,td{
  padding:12px 16px;
  border-bottom:1px solid rgba(0,0,0,.05);
  text-align:left;
  white-space:nowrap;
}
th{
  font-weight:600;
  color:#1b1e2e;
  background:rgba(255,255,255,.6)
}
.lb-medal{
  margin-left:6px;
  font-size:16px;
}

/* Charts */
.chart-card canvas{
  width:100%;
  max-width:100%;
  height:160px;
  display:block;
}

/* thumb preview */
.thumb{
  width:48px;
  height:48px;
  border-radius:10px;
  border:1px solid rgba(0,0,0,.1);
  background-size:cover;
  background-position:center;
  background-color:#eee;
  box-shadow:0 6px 16px rgba(0,0,0,.08);
}

/* Custom layout for task info */
.task-info-group {
  display: flex;
  flex-direction: column;
  justify-content: center;
  flex: 1;
}

.task-top-line {
  display: flex;
  align-items: center;
  gap: 8px;
  flex-wrap: wrap;
  line-height: 1.4;
}

.task-streak-line {
  font-size: 12px;
  font-weight: 600;
  margin-top: 2px;
  display: flex;
  align-items: center;
  gap: 4px;
}

.streak-tag {
  color: #d97706;
  background: rgba(251, 191, 36, 0.15);
  padding: 1px 6px;
  border-radius: 4px;
}
.streak-tag.danger {
  color: #dc2626;
  background: rgba(248, 113, 113, 0.15);
}
.streak-tag.crown {
    color: #7c3aed;
    background: rgba(139, 92, 246, 0.15);
}

  @media (max-width:768px){
    .row{grid-template-columns:1fr}
    .creator{flex-direction:column}
    h1 .app-title{font-size:20px}
  .hero-inner{gap:18px;padding:22px}
  .hero-name{font-size:22px}
  .hero-meta{font-size:15px}
}
@media (max-width:480px){
  body{font-size:15px}
  .tab-btn{padding:8px 12px}
  .tabs{gap:6px}
}
</style>
</head>
<body>

<div class="wrap">
  <h1>
    <span class="app-title" data-app="title">Mori Quest</span>
    <span class="app-version" data-app="version"></span>
  </h1>

  <section id="hero" class="hero">
    <div class="hero-inner">
      <div class="hero-info">
        <div class="hero-name" data-hero="name">Player</div>
        <div class="hero-meta">
          <span class="hero-level" data-hero="level">Level 1</span>
          <span class="hero-xp" data-hero="xp">0 E</span>
          <span class="hero-weekly" data-hero="weekly-avg">TB tu·∫ßn: --</span>
        </div>
        <div class="hero-progress">
          <div class="hero-progress-bar">
            <div class="hero-progress-fill" data-hero="xp-fill"></div>
          </div>
          <div class="hero-progress-label" data-hero="xp-label">0 / 100 E</div>
        </div>
      </div>
    </div>
  </section>

  <div class="tabs" id="tabsBar"></div>

  <div id="view">ƒêang n·∫°p‚Ä¶</div>
</div>

<script>
/* ==============================
   CONFIG
============================== */
const APP_NAME = 'Mori Quest';

const CONFIG = {
  VERSION:'3.1',
  SETTINGS_PASS:'1000',
  HERO_LEVELS:[
    {
      minLevel:1,
      maxLevel:3,
      characterImg:"",
      backgroundImg:'linear-gradient(135deg,#fde68a 0%,#f97316 100%)'
    },
    {
      minLevel:4,
      maxLevel:6,
      characterImg:"",
      backgroundImg:'linear-gradient(135deg,#bae6fd 0%,#2563eb 100%)'
    },
    {
      minLevel:7,
      characterImg:"",
      backgroundImg:'linear-gradient(135deg,#e9d5ff 0%,#7c3aed 100%)'
    }
  ]
};

// Backgrounds
const RAW_APP_BG = "https://raw.githubusercontent.com/PuongLee269/HelloWorld/cc1ea4b1d90dab277ff5138dc9eb9e928986d9ef/image/ChatGPT%20Image%2022_24_20%2031%20thg%2010%2C%202025.png";
const RAW_LEVEL_BG = "https://raw.githubusercontent.com/PuongLee269/HelloWorld/747e7bfebad622025035376e42939a217dde236b/image/ChatGPT%20Image%2016_04_12%2028%20thg%2010%2C%202025.png";

CONFIG.BACKGROUND_THEME = {
  appDefaultBgUrl: `url('${RAW_APP_BG}')`,
  heroByLevel: [
    { minLevel: 1, maxLevel: 3, heroBgUrl: `url('${RAW_LEVEL_BG}')`, appBgUrl: `url('${RAW_APP_BG}')` },
    { minLevel: 4, maxLevel: 6, heroBgUrl: `url('${RAW_LEVEL_BG}')`, appBgUrl: `url('${RAW_APP_BG}')` },
    { minLevel: 7, heroBgUrl: `url('${RAW_LEVEL_BG}')`, appBgUrl: `url('${RAW_APP_BG}')` }
  ]
};

window.APP_CONFIG = CONFIG;
const APP_VERSION = CONFIG.VERSION;

(function syncAppMeta(){
  const versionLabel = `v${APP_VERSION}`;
  document.title = `${APP_NAME} ‚Äì ${versionLabel}`;
  const nameEl = document.querySelector('[data-app="title"]');
  if(nameEl) nameEl.textContent = APP_NAME;
  const versionEl = document.querySelector('[data-app="version"]');
  if(versionEl) versionEl.textContent = versionLabel;
})();

/* ==============================
   LOCAL STORAGE KEYS
============================== */
const LS = {
  PROFILE:'tq_profile',
  ZONES:'tq_zones',
  TASKS:'tq_tasks',
  RECUR:'tq_recurring',
  DAY:'tq_sim_day',
  BONUS:'tq_bonus_flags',
  SPAWN:'tq_spawned_day',
  LBCACHE:'tq_lb_cache',
  HIST:'tq_hist',
  REALDATE:'tq_real_date',
  ARCHIVE:'tq_archive',
  ZONE_E_BONUS_DAY:'tq_zone_e_bonus_day',
  NOISE_STREAKS:'tq_noise_streaks',
  THEME:'tq_theme',
  ZONE_E_STREAKS:'tq_zone_e_streaks',
  NOTES:'tq_notes'
};

function normalizeArchiveText(raw){
  const text = String(raw || '').trim();
  if(!text) return '';
  const normalized = typeof text.normalize === 'function'
    ? text.normalize('NFKC')
    : text;
  return normalized.toLowerCase().replace(/\s+/g, ' ');
}

function normalizeArchiveEntry(raw){
  let text = '';
  if(typeof raw === 'string') text = raw;
  else if(raw && typeof raw === 'object') text = raw.text != null ? raw.text : '';
  const clean = String(text || '').trim();
  const key = normalizeArchiveText(clean);
  if(!key) return null;
  return { text: clean };
}

function getArchive(){
  const raw = load(LS.ARCHIVE, []);
  if(!Array.isArray(raw)) return [];
  const seen = new Set();
  const result = [];
  for(const item of raw){
    const entry = normalizeArchiveEntry(item);
    if(!entry) continue;
    const key = normalizeArchiveText(entry.text);
    if(seen.has(key)) continue;
    seen.add(key);
    result.push(entry);
  }
  return result;
}

function setArchive(list){
  if(!Array.isArray(list)) list = [];
  const seen = new Set();
  const normalized = [];
  for(const item of list){
    const entry = normalizeArchiveEntry(item);
    if(!entry) continue;
    const key = normalizeArchiveText(entry.text);
    if(seen.has(key)) continue;
    seen.add(key);
    normalized.push(entry);
  }
  save(LS.ARCHIVE, normalized);
}

const ZONE_KIND_LABELS = {
  'e':'Zone E',
  'priority':'Zone Quan tr·ªçng',
  'noise':'Zone Noise',
  'regular':'Zone Th∆∞·ªùng'
};
const ZONE_KIND_ORDER = ['e','priority','noise','regular'];
const DEFAULT_ZONES = ZONE_KIND_ORDER.map((kind)=>({
  name: ZONE_KIND_LABELS[kind], kind, bg:''
}));
const DAILY_ZONE_KINDS = new Set(['e','noise']);
const ARCHIVE_ZONE_KINDS = new Set(['priority','regular']);

/* ==============================
   HERO & LEVELS
============================== */
const heroEl = document.getElementById('hero');
const heroRefs = heroEl ? {
  name: heroEl.querySelector('[data-hero="name"]'),
  level: heroEl.querySelector('[data-hero="level"]'),
  xp: heroEl.querySelector('[data-hero="xp"]'),
  weeklyAvg: heroEl.querySelector('[data-hero="weekly-avg"]'),
  xpFill: heroEl.querySelector('[data-hero="xp-fill"]'),
  xpLabel: heroEl.querySelector('[data-hero="xp-label"]')
} : {};

const LEVELS = [
  {lvl:1, need:100}, {lvl:2, need:250}, {lvl:3, need:500},
  {lvl:4, need:800}, {lvl:5, need:1200}, {lvl:6, need:1700},
  {lvl:7, need:2300}, {lvl:8, need:3000}, {lvl:9, need:3800},
];

function calcTotalE(level, xp){
  const lvl = Number(level) || 0;
  const currentXP = Number(xp) || 0;
  let total = currentXP;
  for(const cfg of LEVELS){
    if(cfg.lvl >= lvl) break;
    total += Number(cfg.need) || 0;
  }
  return total;
}

function calcWeeklyAverageEGain(profile){
  const currentProfile = (profile && typeof profile === 'object') ? profile : getProfile();
  const hist = getHist();
  if(!Array.isArray(hist) || hist.length < 6) return null;
  const recent = hist.slice(-6).map((entry) => ({
    ts: Number(entry && entry.ts) || 0,
    total: calcTotalE(entry && entry.level, entry && entry.xp)
  }));
  if(recent.length < 6) return null;
  const series = recent.concat({
    ts: Date.now(),
    total: calcTotalE(currentProfile && currentProfile.level, currentProfile && currentProfile.xp)
  });
  series.sort((a, b) => a.ts - b.ts);
  if(series.length < 7) return null;
  let totalGain = 0;
  for(let i = 1; i < series.length; i++){
    totalGain += series[i].total - series[i - 1].total;
  }
  return totalGain / 7;
}

/* ==============================
   HELPERS
============================== */
function load(key, def){ try{ return JSON.parse(localStorage.getItem(key)) ?? def }catch{ return def } }
function save(key, val){ localStorage.setItem(key, JSON.stringify(val)) }

function getNotes(){ return localStorage.getItem(LS.NOTES) || ''; }
function saveNotes(text){
  const content = String(text || '');
  if(content) localStorage.setItem(LS.NOTES, content);
  else localStorage.removeItem(LS.NOTES);
}

function getSavedThemeBackgrounds(){
  const raw = load(LS.THEME, {});
  const appBgUrl = raw && typeof raw.appBgUrl === 'string' ? raw.appBgUrl : '';
  const heroBgUrl = raw && typeof raw.heroBgUrl === 'string' ? raw.heroBgUrl : '';
  return { appBgUrl, heroBgUrl };
}
function updateSavedThemeBackgrounds(partial){
  partial = partial || {};
  const current = getSavedThemeBackgrounds();
  const next = Object.assign({}, current);
  if('appBgUrl' in partial) next.appBgUrl = partial.appBgUrl || '';
  if('heroBgUrl' in partial) next.heroBgUrl = partial.heroBgUrl || '';
  save(LS.THEME, next);
  return next;
}

// --- COMPLEX ZONE E LOGIC STORE ---
// { "rec:123": { points: 1, streak: 0, progress: 0, threshold: 5 } }
function getZoneEStreakStore(){
  const raw = load(LS.ZONE_E_STREAKS, {});
  if(!raw || typeof raw !== 'object') return {};
  return raw;
}
function setZoneEStreakStore(store){
  save(LS.ZONE_E_STREAKS, store);
}

function getNoiseTaskKey(task){
  if(!task || typeof task !== 'object') return null;
  if(typeof task.recurringId === 'number') return `rec:${task.recurringId}`;
  if(task.id != null) return `task:${task.id}`;
  return null;
}

function generateProfileId(){
  const time = Date.now().toString(36);
  const rand = Math.random().toString(36).slice(2,10);
  return `p-${time}-${rand}`;
}
function formatSignedNumber(n){
  const val = Number(n)||0;
  return `${val>=0?'+':''}${val}`;
}
function todayDM(){
  const d=new Date();
  const dd=String(d.getDate()).padStart(2,'0');
  const mm=String(d.getMonth()+1).padStart(2,'0');
  return `${dd}-${mm}`;
}
function getLastRealDate(){ return localStorage.getItem(LS.REALDATE) || ''; }
function setLastRealDate(val){ if(val) localStorage.setItem(LS.REALDATE, val); }
function lastLevelCfg(){ return LEVELS[LEVELS.length-1]; }

/* ==============================
   SCORING LOGIC (FIXED)
============================== */
function getTaskPoints(text, zoneKind) {
  let pts = 1;
  if(zoneKind === 'e') pts = 1;
  else if(zoneKind === 'priority') pts = 3;
  else if(zoneKind === 'noise') pts = -1;
  else pts = 1;

  return {
      points: pts,
      reason: 'ƒêi·ªÉm c·ªë ƒë·ªãnh',
      category: 'fixed',
      zone: ZONE_KIND_LABELS[zoneKind]
  };
}

/* ==============================
   PROFILE
============================== */
function getProfile(){
  let p = load(LS.PROFILE);
  if(!p || typeof p !== 'object' || Array.isArray(p)){
    p = { id: generateProfileId(), name:'', level:1, xp:0 };
    save(LS.PROFILE, p);
  }
  return p;
}
function setName(name){
  const p=getProfile(); p.name=(name||'').trim(); save(LS.PROFILE,p);
  renderHero();
}
function addXP(delta){
  const p=getProfile();
  p.xp = Math.max(0, Number(p.xp||0)+Number(delta||0));
  while(true){
    const cfg = LEVELS.find(x=>x.lvl===p.level) || lastLevelCfg();
    const need = cfg.need || 0;
    if(need>0 && p.xp>=need){
      p.xp -= need;
      const maxLvl = lastLevelCfg().lvl;
      p.level = Math.min(maxLvl, p.level+1);
    } else break;
  }
  save(LS.PROFILE,p);
  renderHero();
}
function getLevelInfo(){
  const p=getProfile();
  const cfg = LEVELS.find(x=>x.lvl===p.level) || lastLevelCfg();
  return {level:p.level, xp:p.xp, need:cfg.need||0};
}
function resetPoints(){
  const p=getProfile(); p.level=1; p.xp=0; save(LS.PROFILE,p);
  renderHero();
}
function ensureName(){
  const p=getProfile();
  if(!p.name){ const n=prompt('Nh·∫≠p t√™n ng∆∞·ªùi ch∆°i:'); if(n) setName(n); }
}

/* ==============================
   RENDER HERO
============================== */
function pickHeroBackgroundThemeFor(level){
  const theme = getBackgroundTheme();
  const list = Array.isArray(theme.heroByLevel) ? theme.heroByLevel : [];
  const fallback = list[list.length-1] || null;
  for(const item of list){
     if(level>=item.minLevel && (!item.maxLevel || level<=item.maxLevel)) return item;
  }
  return fallback;
}

function applyBackgroundToElement(el, value, fallbackValue, options){
  if(!el) return;
  const final = value || fallbackValue || '';
  el.style.backgroundImage = final;
  if(options.size) el.style.backgroundSize = options.size;
  if(options.position) el.style.backgroundPosition = options.position;
  if(options.attachment) el.style.backgroundAttachment = options.attachment;
}

function renderHero(){
  if(!heroEl) return;
  const profile = getProfile();
  const {level,xp,need} = getLevelInfo();
  const backgroundTheme = getBackgroundTheme();
  const heroThemePreset = pickHeroBackgroundThemeFor(level) || {};
  const name = (profile.name || '').trim() || 'Player';
  const pct = need ? Math.min(100, Math.round(xp/need*100)) : 100;
  const weeklyAvgGain = calcWeeklyAverageEGain(profile);

  const customHeroBg = backgroundTheme.customHeroBgUrl || '';
  const customAppBg = backgroundTheme.customAppBgUrl || '';
  const defaultHeroBg = 'linear-gradient(135deg,#8b7cff 0%,#b09bff 100%)';
  const heroBgValue = customHeroBg || heroThemePreset.heroBgUrl || '';
  
  applyBackgroundToElement(heroEl, heroBgValue, defaultHeroBg, { size:'cover', position:'center' });

  const appBgFallback = backgroundTheme.appDefaultBgUrl || '';
  const appBgValue = customAppBg || heroThemePreset.appBgUrl || '';
  applyBackgroundToElement(document.body, appBgValue, appBgFallback, { size:'cover', attachment:'fixed' });

  if(heroRefs.name) heroRefs.name.textContent = name;
  if(heroRefs.level) heroRefs.level.textContent = `Level ${level}`;
  if(heroRefs.xp) heroRefs.xp.textContent = `${xp} E`;
  if(heroRefs.weeklyAvg){
    if(weeklyAvgGain === null) heroRefs.weeklyAvg.textContent = 'TB tu·∫ßn: --';
    else heroRefs.weeklyAvg.textContent = `TB tu·∫ßn: ${formatSignedNumber(weeklyAvgGain.toFixed(1))} E/ng√†y`;
  }
  if(heroRefs.xpLabel) heroRefs.xpLabel.textContent = need ? `${xp} / ${need} E t·ªõi level ti·∫øp theo` : `${xp} E (t·ªëi ƒëa)`;
  if(heroRefs.xpFill) heroRefs.xpFill.style.width = `${pct}%`;
}

/* ==============================
   HISTORY & DAY
============================== */
function getHist(){ return load(LS.HIST,[]); }
function setHist(h){ save(LS.HIST,h); }
function pushHistSnapshot(){
  const p=getProfile();
  const h=getHist();
  h.push({ ts:Date.now(), level:p.level, xp:p.xp });
  if(h.length>60) h.splice(0, h.length-60);
  setHist(h);
}
function getDay(){
  let d=Number(localStorage.getItem(LS.DAY)||0);
  if(!d){ d=1; localStorage.setItem(LS.DAY,d); }
  return d;
}
function nextDay(){
  const d=getDay()+1;
  localStorage.setItem(LS.DAY,d);
  return d;
}
function loadFlags(){ return load(LS.BONUS,{}); }
function saveFlags(f){ save(LS.BONUS,f); }
function clearFlagsFor(day){
  const f=loadFlags(); delete f[day]; saveFlags(f);
}

/* ==============================
   ZONES / TASKS
============================== */
function getZones(){
  let zones = load(LS.ZONES, []);
  if(!zones.length){
      zones = DEFAULT_ZONES.map((z, idx)=>({
      id: Date.now() + idx,
      name: z.name,
      kind: z.kind,
      bg: z.bg
    }));
    save(LS.ZONES, zones);
  }
  return zones;
}
function setZones(z){ save(LS.ZONES,z) }
function updZone(id,patch){
  const zones = getZones().map(z=>z.id===id?{...z,...patch}:z);
  setZones(zones);
}
function delZone(id){
  setZones(getZones().filter(z=>z.id!==id));
}

async function addRecurring(r){
  const rec = {...r};
  rec.id = Date.now() + Math.floor(Math.random()*1000);
  
  const zones = getZones();
  const z = zones.find(z => z.id == rec.zoneId);
  const zoneKind = z ? z.kind : 'regular';
  
  const pts = getTaskPoints(rec.text, zoneKind);
  rec.points = pts.points;
  
  const list = [...getRecurring(), rec];
  save(LS.RECUR, list);
  return rec;
}

function delRecurring(id){
  save(LS.RECUR,getRecurring().filter(r=>r.id!==id));
}
function getRecurring(){ return load(LS.RECUR,[]) }
function getTasks(){ return load(LS.TASKS, []) }
function setTasks(a){ save(LS.TASKS,a) }

function isTaskActiveToday(t){
  if(!t) return false;
  if(t.kind==='recurring') return true;
  return !t.done;
}
function doesTaskOccupyCapacity(task){ return !!task; }
function getZoneActiveTasks(tasks, zoneId){
  return tasks.filter(t=>t.zoneId==zoneId && doesTaskOccupyCapacity(t));
}

function renderTaskKindBadge(t, z){
  if(t.kind==='recurring') return `<span class="task-kind recurring">H·∫±ng ng√†y</span>`;
  return `<span class="task-kind single">M·ªôt l·∫ßn</span>`;
}

function renderTaskPoints(points, reasonText, options) {
  const opts = options || {};
  const sign = points >= 0 ? '+' : '';
  const className = points >= 0 ? 'positive' : 'negative';
  const icon = opts.icon ? `<span class="task-point-icon" aria-hidden="true">${opts.icon}</span>` : '';
  return `<span class="task-points ${className}" title="${opts.tooltip||''}">${icon}${sign}${points}</span>`;
}

function getTaskPointExtras(task, zoneKind, stores){
  if(!task || !stores) return {};
  const zoneEStore = stores.zoneE || {};

  if(zoneKind === 'e' && task.kind === 'recurring'){
    const key = getNoiseTaskKey(task);
    if(key && zoneEStore[key]){
      const d = zoneEStore[key];
      const isCrown = d.points >= 7;
      return {
        icon: isCrown ? 'üëë' : '',
        tooltip: `Streak: ${d.streak}, Progress: ${d.progress}/${d.threshold} to +1`
      };
    }
  }
  if(zoneKind === 'noise' && task.points < -1){
      return { icon: 'üíÄ', tooltip: 'Ph·∫°t n·∫∑ng' };
  }
  return {};
}

function isArchiveEligibleKind(kind){ return ARCHIVE_ZONE_KINDS.has(kind); }
function archiveTaskCompletion(task, zone){
  if(!task || !zone || !isArchiveEligibleKind(zone.kind)) return;
  const text = String(task.text || '').trim();
  const current = getArchive();
  if(!current.some(i => normalizeArchiveText(i.text) === normalizeArchiveText(text))){
      setArchive([...current, {text}]);
  }
}
function removeTaskFromArchive(taskText){
  const key = normalizeArchiveText(taskText);
  setArchive(getArchive().filter(item => normalizeArchiveText(item.text) !== key));
}

/* ==============================
   DAY ROLLOVER & SPAWN
============================== */
function spawnRecurringIfNeeded(){
  const mark = Number(localStorage.getItem(LS.SPAWN)||0);
  if(mark===getDay()) return;

  const weekday = new Date().getDay();
  const recs = getRecurring();
  const zones = getZones();
  const tasks = getTasks();
  const zoneEMap = getZoneEStreakStore();
  
  const existingRecurring = new Set(
    tasks
      .filter(t=>t.kind==='recurring' && typeof t.recurringId==='number')
      .map(t=>t.recurringId)
  );

  for(const r of recs){
    const match = r.type==='daily' || (r.type==='weekly' && Array.isArray(r.days)&&r.days.includes(weekday));
    if(!match) continue;
    if(existingRecurring.has(r.id)) continue;
    
    const z = zones.find(z=>z.id==r.zoneId);
    if(!z) continue;

    // Determine points for new spawn
    let pts = Number(r.points);
    // For Zone E, pull current level points
    if (z.kind === 'e') {
         const d = zoneEMap[`rec:${r.id}`];
         if (d) pts = d.points;
         else pts = 1;
    }
    
    const newTask = {
      id: Date.now() + Math.random(),
      text: r.text,
      zoneId: r.zoneId,
      done: false,
      kind: 'recurring',
      recurringId: r.id,
      points: pts
    };
    tasks.push(newTask);
  }

  setTasks(tasks);
  localStorage.setItem(LS.SPAWN, String(getDay()));
}

function performDayRollover(opts={}){
  const auto=!!opts.auto;
  if(isRolloverRunning) return false;
  isRolloverRunning=true;
  try {
    const zones = getZones();
    const tasks = getTasks();
    const recs = getRecurring();
    const zoneEMap = getZoneEStreakStore();
    const nextZoneEMap = {...zoneEMap};
    const zoneKindMap = new Map(zones.map(z => [z.id, z.kind]));

    // 1. Penalty -7E
    addXP(-7);

    // 2. Daily Zone E Bonus (>3 tasks)
    const todayTasks = tasks.filter(t => t.done);
    const countE = todayTasks.filter(t => zoneKindMap.get(t.zoneId) === 'e').length;
    if(countE > 3) {
        addXP(Math.min(5, Math.max(3, countE)));
    }

    // 3. Advanced Zone E Leveling Logic
    recs.forEach(r => {
        if(zoneKindMap.get(r.zoneId) !== 'e') return;
        const key = `rec:${r.id}`;
        // Initialize if missing
        if(!nextZoneEMap[key]) nextZoneEMap[key] = { points: 1, streak: 0, progress: 0, threshold: 5 };
        
        const d = nextZoneEMap[key];
        // Check if performed today
        const performed = todayTasks.some(t => t.recurringId === r.id);

        if(performed) {
            d.streak++;
            // Level up logic only if < 7 (Crown)
            if(d.points < 7) {
                d.progress++;
                if(d.progress >= d.threshold) {
                    d.points++; // Level up
                    d.progress = 0;
                    d.threshold = Math.ceil(d.threshold * 1.2); // Harder next time
                }
            }
        } else {
            // Missed day logic
            if(d.points >= 7) {
                // Has crown -> drop 1 level
                d.points--;
                d.progress = 0;
                d.threshold = Math.floor(d.threshold / 1.2) || 5; // Approximate step down
            } else {
                // No crown -> reset to 1
                d.points = 1;
                d.progress = 0;
                d.threshold = 5;
                d.streak = 0;
            }
        }
    });
    setZoneEStreakStore(nextZoneEMap);

    // 4. Zone Noise Logic (Accumulate penalty if done)
    recs.forEach(r => {
        if(zoneKindMap.get(r.zoneId) !== 'noise') return;
        const performed = todayTasks.some(t => t.recurringId === r.id);
        if(performed) {
            // Increase penalty (more negative)
            r.points = (r.points || -1) - 1; 
        }
    });
    save(LS.RECUR, recs);

    // 5. Cleanup
    pushHistSnapshot();
    clearFlagsFor(getDay());
    nextDay();
    
    // Remove done recurring tasks, keep undone single tasks
    const remaining = tasks.filter(t => t.kind === 'single' && !t.done);
    setTasks(remaining);
    
    localStorage.removeItem(LS.SPAWN);
    spawnRecurringIfNeeded();
    setLastRealDate(todayDM());
    
    renderHero();
    if(!auto) {
        render('settings');
        alert('ƒê√£ qua ng√†y m·ªõi! B·∫°n b·ªã tr·ª´ 7 E ph√≠ sinh ho·∫°t.');
    }
    return true;
  } finally {
    isRolloverRunning=false;
  }
}

function handleEndDay(){
  performDayRollover({auto:false});
}

function handleResetPoints(){
  if(confirm('Reset Level=1 & E=0?')){
    resetPoints();
    alert('ƒê√£ reset ƒëi·ªÉm.');
    render('settings');
  }
}

function syncDayWithCalendar(){
  const today = todayDM();
  const lastReal = getLastRealDate();
  if(!lastReal){
    setLastRealDate(today);
    return false;
  }
  if(lastReal===today){
    return false;
  }
  return performDayRollover({auto:true});
}

function startDaySyncMonitoring(){
  if(daySyncTimer!==null) return;
  daySyncTimer=setInterval(()=>{
    if(syncDayWithCalendar()){
      render('tasks');
    }
  }, 60*1000);
  if(!daySyncVisHandler){
    daySyncVisHandler=()=>{
      if(!document.hidden && syncDayWithCalendar()){
        render('tasks');
      }
    };
    document.addEventListener('visibilitychange', daySyncVisHandler);
  }
}

function stopDaySyncMonitoring(){
  if(daySyncTimer!==null){
    clearInterval(daySyncTimer);
    daySyncTimer=null;
  }
  if(daySyncVisHandler){
    document.removeEventListener('visibilitychange', daySyncVisHandler);
    daySyncVisHandler=null;
  }
}

/* ==============================
   ORIGINAL CHART DRAWER
============================== */
function drawChart(canvasId, values){
  const cvs = document.getElementById(canvasId);
  if(!cvs) return;
  const ctx = cvs.getContext('2d');

  const ratio = window.devicePixelRatio || 1;
  const displayWidth = Math.floor(cvs.clientWidth || cvs.offsetWidth || 300);
  const displayHeight = Math.floor(cvs.clientHeight || cvs.offsetHeight || 160);
  if(displayWidth === 0 || displayHeight === 0) return;

  cvs.width = Math.round(displayWidth * ratio);
  cvs.height = Math.round(displayHeight * ratio);

  ctx.setTransform(1,0,0,1,0,0);
  ctx.scale(ratio, ratio);
  ctx.clearRect(0,0,displayWidth,displayHeight);
  ctx.lineJoin = ctx.lineCap = 'round';

  ctx.fillStyle = "rgba(255,255,255,0.6)";
  ctx.fillRect(0,0,displayWidth,displayHeight);

  if(!values || !values.length){
    ctx.fillStyle="#555";
    ctx.font="14px system-ui";
    ctx.textBaseline = 'top';
    ctx.fillText("Ch∆∞a c√≥ d·ªØ li·ªáu", 10, 24);
    return;
  }

  const minV = Math.min(...values);
  const maxV = Math.max(...values);
  const padX = 24, padY = 24;
  const span = (maxV-minV)||1;
  const usableW = (displayWidth-2*padX);
  const usableH = (displayHeight-2*padY);

  const points = values.map((v,i)=>{
    const ratioX = (values.length===1)?0:(i/(values.length-1));
    const x = padX + (usableW * ratioX);
    const y = displayHeight - padY - (usableH * ((v-minV)/span));
    return {x,y,value:v};
  });

  // Grid
  ctx.save();
  ctx.strokeStyle = 'rgba(27,30,46,0.08)';
  ctx.lineWidth = 1;
  ctx.setLineDash([4,6]);
  for(let i=0;i<=4;i++){
    const gy = padY + (usableH * (i/4));
    ctx.beginPath();
    ctx.moveTo(padX, gy);
    ctx.lineTo(displayWidth-padX, gy);
    ctx.stroke();
  }
  ctx.restore();

  // Gradient Line
  const gradLine = ctx.createLinearGradient(padX,0,displayWidth-padX,0);
  gradLine.addColorStop(0,"#8b7cff");
  gradLine.addColorStop(1,"#b09bff");

  ctx.beginPath();
  points.forEach((pt,i)=>i==0?ctx.moveTo(pt.x, pt.y):ctx.lineTo(pt.x, pt.y));
  ctx.lineWidth = 3;
  ctx.strokeStyle = gradLine;
  ctx.shadowColor = 'rgba(139,124,255,0.35)';
  ctx.shadowBlur = 12;
  ctx.stroke();
  ctx.shadowColor = 'transparent';
  ctx.shadowBlur = 0;

  // Fill
  ctx.beginPath();
  points.forEach((pt,i)=>i==0?ctx.moveTo(pt.x, pt.y):ctx.lineTo(pt.x, pt.y));
  ctx.lineTo(points[points.length-1].x, displayHeight-padY);
  ctx.lineTo(points[0].x, displayHeight-padY);
  ctx.closePath();
  const gradFill = ctx.createLinearGradient(0,padY,0,displayHeight-padY);
  gradFill.addColorStop(0,'rgba(139,124,255,0.18)');
  gradFill.addColorStop(1,'rgba(139,124,255,0)');
  ctx.fillStyle = gradFill;
  ctx.fill();

  // Dots
  points.forEach((pt,i)=>{
    ctx.beginPath();
    const isLast = i === points.length-1;
    ctx.arc(pt.x, pt.y, isLast?5:3, 0, Math.PI*2);
    ctx.fillStyle = isLast?'#ff3425':'#fff';
    ctx.strokeStyle = isLast?'rgba(255,255,255,0.85)':'rgba(139,124,255,0.6)';
    ctx.lineWidth = isLast?3:2;
    ctx.fill();
    ctx.stroke();
  });
}

/* ==============================
   FULL SWIPE HANDLERS
============================== */
function attachSwipeHandlersForTasks(){
  const rows = [...document.querySelectorAll('li.task')];
  rows.forEach(li=>{
    const inner = li.querySelector('.task-inner');
    const delBtn = li.querySelector('.del-btn');
    let startX = 0, currentX = 0, isDown = false;
    let opened = li.classList.contains('show-del');
    let justSwiped = false;
    let swipeResetTimer = null;
    let hasDragged = false;
    let pendingDragFromDel = false;
    let pendingStartX = 0;

    function openRow(){
      li.classList.add('show-del'); li.classList.remove('dragging');
      inner.style.transform = ''; delBtn.style.transform = ''; opened = true;
    }
    function closeRow(){
      li.classList.remove('show-del'); li.classList.remove('dragging');
      inner.style.transform = ''; delBtn.style.transform = 'translateX(60px)';
      opened = false; justSwiped = false;
    }
    function applyDrag(dx){
      let offset = dx; if(offset<-60) offset=-60; if(offset>0) offset=0;
      inner.style.transform = `translateX(${offset}px)`;
      delBtn.style.transform = `translateX(${60+offset}px)`;
    }
    function startDrag(clientX){
      isDown = true; hasDragged = false; pendingDragFromDel = false;
      startX = clientX; currentX = clientX; li.classList.add('dragging');
      if(opened){ inner.style.transform='translateX(-60px)'; delBtn.style.transform='translateX(0px)'; }
    }
    function canStartDrag(target, clientX){
      if(target.closest('.del-btn')) return true;
      if(target.closest('input, button, select, textarea, a, label')) return false;
      if(target.closest('.task-inner') || target.closest('.txt')) return true;
      const liRect = li.getBoundingClientRect();
      return clientX >= (liRect.right - 60);
    }
    function moveDrag(clientX){
      if(!isDown) return;
      currentX = clientX; const dx = currentX - startX;
      if(opened) applyDrag(-60 + dx); else applyDrag(dx);
    }
    function endDrag(){
      if(!isDown) return;
      isDown = false; const dx = currentX - startX;
      let openedViaSwipe = false;
      if(opened){ if(dx>30) closeRow(); else { openRow(); openedViaSwipe=true; } }
      else { if(dx<-30) { openRow(); openedViaSwipe=true; } else closeRow(); }
      if(openedViaSwipe){
        justSwiped=true;
        if(swipeResetTimer) clearTimeout(swipeResetTimer);
        swipeResetTimer=setTimeout(()=>{justSwiped=false;swipeResetTimer=null;},250);
      }
      hasDragged = false;
    }

    // Touch
    li.addEventListener('touchstart', e=>{
      const cx = e.touches[0].clientX;
      if(e.target.closest('.del-btn')){ pendingDragFromDel=true; pendingStartX=cx; return; }
      pendingDragFromDel=false; pendingStartX=0;
      if(!canStartDrag(e.target, cx)) return;
      startDrag(cx);
    }, {passive:false});
    li.addEventListener('touchmove', e=>{
      const cx = e.touches[0].clientX;
      if(pendingDragFromDel){
        const dx = cx - pendingStartX;
        if(Math.abs(dx)>3){ startDrag(pendingStartX); hasDragged=true; moveDrag(cx); e.preventDefault(); }
        return;
      }
      if(!isDown) return;
      const dx = cx - startX;
      if(!hasDragged && Math.abs(dx)>3) hasDragged=true;
      if(hasDragged){ moveDrag(cx); e.preventDefault(); }
    }, {passive:false});
    li.addEventListener('touchend', ()=>{
      if(pendingDragFromDel){ pendingDragFromDel=false; pendingStartX=0; return; }
      endDrag();
    });
    // Mouse
    li.addEventListener('mousedown', e=>{
      if(!canStartDrag(e.target, e.clientX)) return;
      startDrag(e.clientX); e.preventDefault();
    });
    li.addEventListener('mousemove', e=>{ if(!isDown) return; moveDrag(e.clientX); });
    li.addEventListener('mouseup', endDrag);
    li.addEventListener('mouseleave', ()=>{ if(isDown) endDrag(); });
    
    inner.addEventListener('click', e=>{
      if(li.classList.contains('show-del')){
        e.preventDefault(); e.stopPropagation();
        if(!justSwiped) closeRow();
      }
    });
  });
}

/* ==============================
   ROUTER
============================== */
let currentTab='tasks';

function render(tab){
  currentTab = tab;
  renderHero();
  buildTabsBar(tab);

  if(tab==='tasks'){
    stopDaySyncMonitoring();
    syncDayWithCalendar();
    viewTasks();
    startDaySyncMonitoring();
  } else if(tab==='archive'){
    stopDaySyncMonitoring();
    viewArchive();
  } else if(tab==='leaderboard'){
    stopDaySyncMonitoring();
    viewLeaderboard();
  } else if(tab==='stats'){
    stopDaySyncMonitoring();
    viewStats();
  } else if(tab==='notes'){
    stopDaySyncMonitoring();
    viewNotes();
  } else if(tab==='settings'){
    stopDaySyncMonitoring();
    if(ensureSettingsAuth()) viewSettings();
    else render('tasks');
  } else {
    render('tasks');
  }
}

/* ==============================
   VIEWS
============================== */
async function viewTasks(){
  spawnRecurringIfNeeded();
  let zones=getZones();
  const tasks=getTasks();
  const zoneEMap = getZoneEStreakStore();
  const dateNowDM = todayDM();
  
  // Ensure Priority Zone
  if (!zones.some(z => z.kind === 'priority')) {
    zones.push({id: Date.now(), name: 'Zone Quan tr·ªçng', kind: 'priority', bg: ''});
    setZones(zones);
  }

  const groups = zones.map(z=>{
    const list = tasks.filter(t=>t.zoneId==z.id);
    return { z, list, count: list.length, done: list.filter(t=>t.done).length };
  });

  view.innerHTML = `
    <div class="top">
      <span class="pill">Ng√†y: <b>${dateNowDM}</b></span>
    </div>
    <div class="creator">
      <input id="taskText" placeholder="Th√™m nhi·ªám v·ª•‚Ä¶ (Enter)">
      <select id="taskZone">${zones.map(z=>`<option value="${z.id}">${z.name}</option>`).join('')}</select>
      <button class="btn-primary" id="btnAdd">Th√™m</button>
    </div>
    ${groups.map(g=>{
      const headerStyle = g.z.bg ? `background-image:linear-gradient(0deg,rgba(0,0,0,.5),rgba(0,0,0,.15)),url('${g.z.bg}');` : '';
      const listHtml = g.list.map(t=>{
        let subHtml = '';
        // Logic Zone E Text
        if(g.z.kind === 'e' && t.kind === 'recurring'){
             const key = `rec:${t.recurringId}`;
             if(zoneEMap[key]){
                 const d = zoneEMap[key];
                 const isCrown = d.points >= 7;
                 subHtml = `
                 <div class="task-streak-line">
                    <span class="streak-tag ${isCrown?'crown':''}">${isCrown?'üëë':''} Streak: ${d.streak} ng√†y</span>
                    ${!isCrown ? `<span class="muted" style="font-size:11px;margin-left:4px">(${d.progress}/${d.threshold} ƒë·ªÉ +1 E)</span>` : ''}
                 </div>`;
             }
        }
        // Logic Zone Noise Text
        if(g.z.kind === 'noise' && t.points < -1){
             subHtml = `<div class="task-streak-line"><span class="streak-tag danger">üíÄ Ph·∫°t n·∫∑ng: ${t.points} E</span></div>`;
        }

        return `
          <li class="task ${t.done?'done':''}" data-id="${t.id}">
            <div class="task-inner">
              <div class="left">
                <input type="checkbox" ${t.done?'checked':''} onchange="toggleTask(${t.id}, this.checked)">
                <div class="task-info-group">
                   <div class="task-top-line">
                      <span class="txt">${t.text}</span>
                      ${renderTaskKindBadge(t, g.z)}
                      <span class="task-points ${t.points>=0?'positive':'negative'}">${t.points>0?'+':''}${t.points}</span>
                   </div>
                   ${subHtml}
                </div>
              </div>
            </div>
            <button class="del-btn" onclick="deleteTask(${t.id}, '${g.z.kind}', ${t.points})">√ó</button>
          </li>
        `;
      }).join('');

      return `
      <section class="zone">
        <header class="${g.z.bg?'imgHead':''}" style="${headerStyle}">
          <div><b>${g.z.name}</b></div>
          <div class="badge">${g.done}/${g.count}</div>
        </header>
        <ul>${listHtml || '<li class="task"><div class="task-inner muted">Ch∆∞a c√≥ task</div></li>'}</ul>
      </section>`;
    }).join('')}
  `;

  document.getElementById('btnAdd').onclick = addTask;
  document.getElementById('taskText').onkeydown = e => e.key==='Enter' && addTask();
  attachSwipeHandlersForTasks();
}

async function addTask(){
    const txt = document.getElementById('taskText').value.trim();
    const zid = Number(document.getElementById('taskZone').value);
    if(!txt) return;
    const zones = getZones();
    const z = zones.find(x=>x.id===zid);
    const tasks = getTasks();
    
    // Limits
    const active = getZoneActiveTasks(tasks, zid).length;
    if(z.kind === 'e'){
        const limit = getProfile().level >= 2 ? 6 : 5;
        if(active >= limit) return alert(`Zone E gi·ªõi h·∫°n ${limit} task/ng√†y.`);
    }
    if(z.kind === 'priority' && active >= 3) return alert('Zone Quan tr·ªçng t·ªëi ƒëa 3 task.');

    const pts = getTaskPoints(txt, z.kind);
    const newTask = {
        id: Date.now(), text: txt, zoneId: zid, done: false, kind: 'single', points: pts.points
    };

    // Auto recurring for E/Noise
    if(z.kind==='e' || z.kind==='noise'){
        const recs = getRecurring();
        const rid = Date.now();
        recs.push({ id: rid, text: txt, zoneId: zid, type: 'daily', points: pts.points });
        save(LS.RECUR, recs);
        newTask.kind = 'recurring';
        newTask.recurringId = rid;
    }

    tasks.push(newTask);
    setTasks(tasks);
    viewTasks();
}

function toggleTask(id, checked){
    const tasks = getTasks();
    const t = tasks.find(x=>x.id===id);
    if(t){
        t.done = checked;
        addXP(checked ? t.points : -t.points);
        setTasks(tasks);
        const z = getZones().find(z=>z.id==t.zoneId);
        if(checked && isArchiveEligibleKind(z.kind)) archiveTaskCompletion(t, z);
        if(!checked) removeTaskFromArchive(t.text);
        viewTasks();
    }
}

function deleteTask(id, zoneKind, pts){
    // NOISE DELETE LOGIC
    if(zoneKind === 'noise' && pts < -1){
        if(confirm(`Task ƒëang b·ªã ph·∫°t ${pts} ƒëi·ªÉm. Reset v·ªÅ -1 ƒë·ªÉ x√≥a?`)){
            const tasks = getTasks();
            const t = tasks.find(x=>x.id===id);
            if(t){
                t.points = -1;
                if(t.recurringId){
                    const recs = getRecurring();
                    const r = recs.find(x=>x.id==t.recurringId);
                    if(r) r.points = -1;
                    save(LS.RECUR, recs);
                }
                setTasks(tasks);
                viewTasks();
            }
        }
        return;
    }

    const tasks = getTasks();
    const t = tasks.find(x=>x.id===id);
    if(t && t.recurringId) delRecurring(t.recurringId);
    setTasks(tasks.filter(x=>x.id!==id));
    viewTasks();
}

/* ==============================
   BOOT
============================== */
ensureName();
render('tasks');
</script>
</body>
</html>
